\documentclass{hertieteaching}
\newcommand{\sql}{\textsf{SQL}}


\title{Databases!}

\begin{document}

{\setbeamertemplate{footline}{}
  \begin{frame}\maketitle\end{frame}
}
\addtocounter{page}{-1}

\begin{frame}{Databases}

Where the data lives 
\begin{itemize}
  \item Old old technology: \textit{Relational} databases
  \item New new technology: Everything else
\end{itemize}
Think linear vs non-linear functions

\pause
\bigskip
Small secret: the world still runs on relational databases

Larger secret: and will continue to do so for the foreseeable future because they work \textit{really well} for most sorts of data

\end{frame}

\begin{frame}{Relational Databases}

We should distinguish:
\begin{itemize}
  \item The data structure: tables, columns, keys, normal forms
  \item The data manipulations: selects, joins, grouping
  \item The database system, e.g. \textsf{Postgres}, \textsf{Oracle}, \textsf{SQL Server}, \textsf{sqlite}
  \item The query language, e.g. \textsf{SQL}
  \item Server and embedded systems, e.g. \textsf{Oracle} vs \textsf{sqlite}
\end{itemize}

We \textit{won't} cover \textsf{SQL} itself or any particular database system.
\begin{itemize}
  \item Technology and fashions change
\end{itemize}


We \textit{will} cover the essential structures and manipulations, and a little of the system interfaces

\end{frame}

\begin{frame}{Non-relational Databases}

These differ mostly in
\begin{itemize}
  \item The data structure: documents, key-value stores, graphs, tuples
  \item The data manipulations, e.g. search, query
  \item The query language, e.g. native code, \textsf{json}, 
\end{itemize}
But often the same database system (\textsf{Postgres}, \textsf{Oracle}, etc.) has a non-relational module/add-on

Otherwise, dedicated `NoSQL' systems. Some established representatives
\begin{itemize}
  \item \textsf{Couch}, \textsf{Mongo} (documents)
  \item \textsf{Redis}, \textsf{Ignite} (key value)
  \item \textsf{Neo4j} (graphs)
\end{itemize}
 
\end{frame}

\begin{frame}{Relations and Tables}

The data structures: table
\begin{itemize}
  \item You've met tables before -- hint \textsf{data.frame}s are tables: equal length variable-typed columns 
  \item Columns have names and types
  \item No row names or numbers. 
\end{itemize}
\pause

A \textit{primary} key is either
\begin{enumerate}
  \item A column containing a (usually autogenerated) identifiers that uniquely identify each row.  (Unordered, despite what they might look like)
  \item Several substantively meaningful columns whose row values \textit{taken together} uniquely identify each row
\end{enumerate}

\end{frame}

\begin{frame}{Relations and Tables}

Abstractly, we'll think of them all like this

\bigskip
\centerline{\includegraphics{pics/join-setup}}

\bigskip
\centerline{\includegraphics{pics/join-setup2}}

  
\end{frame}


\begin{frame}{Modelling with Tables}
  
In a table of OECD annual multi-sector investment data
a primary key might be 
\begin{itemize}
  \item \textsf{country}, \textsf{year}, \textsf{sector}
\end{itemize}
\textsf{country} and \textsf{year} would be insufficient:
\begin{itemize}
  \item would not pick out a single row 
\end{itemize}
\textsf{country} \textsf{year}, \textsf{sector}, and \textsf{value} \textit{would} be be unique, but impractical

The useful distinction is between identifying the row, and assigning some other values to it using the non-key columns.

Autogenerated primary keys (maybe just \textsf{id}) are the easiest to deal with, and we'll mostly assume these.

\end{frame}

\begin{frame}{About those rows}

We could have represented each of the 4 sector's investment values for each country and year as four extra columns

That would have been \textit{bad}
\begin{itemize}
  \item Sectors can't change without rebuilding the whole database structure
\end{itemize}
We can easily allow adding, removing, and renaming sectors by \textit{making sector a value not a variable}

We try to extend downwards as new rows, not sideways as 
new columns

\centerline{\includegraphics[scale=0.3]{pics/investment-bad}\hspace{2em}\includegraphics[scale=0.3]{pics/investment-good}}

\end{frame}

\begin{frame}{Translation manual}

For economists
\begin{itemize}
  \item wide to long: make variables values
  \item long to wide: make values variables
\end{itemize}

For \textsf{dplyr}-ers
\begin{itemize}
  \item \textsf{gather}, \textsf{pivot\_to\_long}: make variables values
  \item \textsf{spread}, \textsf{pivot\_to\_wide}: make values variables
\end{itemize}

This decision to make sector a 
variable, and value another one (rather than \textsf{sector1\_value}, \textsf{sector2\_value}, etc.) is called 
\textit{normalization}

It's a whole bunch of database theory
\begin{itemize}
  \item Check out 1st through 6th \textit{normal form}
  \item yes, the \textsf{tidyverse} stole the best bits 
\end{itemize}
	
\end{frame}

\begin{frame}{Foreign keys}

We were a bit vague about how country was represented in the OECD investment data
\begin{itemize}
  \item was it a string? 
  \item If so are we using names, or ISO codes, or what?
\end{itemize}
Now we have the opportunity to make it a real thing. Let's say
\begin{itemize}
  \item a country is represented by a row in the \textsf{Country} table
\end{itemize}

Let's model Investment as having columns

\begin{itemize}
  \item \textsf{country\_id}, \textsf{year}, \textsf{sector}, \textsf{value}
\end{itemize}

where \textsf{country\_id} refers to  row of \textsf{Country}

How does it do that?
\end{frame}



\begin{frame}{Foreign keys}

Tables are related by \textit{foreign key} relationships
\begin{itemize}
  \item A foreign key is a column containing primary key(s) \textit{from another table}
\end{itemize}
Example
\begin{itemize}
  \item Table \textsf{Investment} contains annual multisector investment data
  \item Table \textsf{Country} contains facts about each country, e.g. name, political system
\end{itemize}
Assume 20 years of investment data on 33 OECD countries\footnote{I know. This is not quite right because four countries joined in 2010} in 4 sectors
\begin{itemize}
  \item Table \textsf{Investment} has 2640 rows 
  \item Table \textsf{Country} has 33 rows 
\end{itemize}

\end{frame}

\begin{frame}{Foreign keys}
\medskip
\centerline{\includegraphics[scale = 0.6]{pics/foreign-key}}  
\end{frame}

\begin{frame}{Schema}
These sorts of arrangements are the database \textit{schema}

Schemas 
\begin{itemize}
  \item express a model of the substantive domain
  \item define tables, and the columns within them
  \item are tricky to change without disruption
  \item built and maintained by a Database Administrator
\end{itemize}

Data 
\begin{itemize}
  \item represent entities of the types defined in the schema
  \item are represented as rows
  \item are fairly easy to add, edit, and remove without disruption
  \item maintained by Developers and Data entry folk
\end{itemize}

\end{frame}


\begin{frame}{Relational data modeling}

Many rows of \textsf{Investment} refer to the same 1 row of \textsf{Country}, so this is a \textit{many-to-one} relationship
\begin{itemize}
  \item Implemented by adding a foreign key column \textsf{country\_id} to \textsf{Invest} and filling it with the relevant primary key from \textsf{Country} (called \textsf{id} there)
\end{itemize}
If you've programmed an object-oriented language, think of the foreign key as a \textit{reference} to a \textsf{Country} object

If you've worked on ontology before, this is a \textit{has-a} relationship rather than an \textit{is-a}
\begin{itemize}
  \item Relational databases understand the world \textit{entirely} in these terms
\end{itemize}


\end{frame}

\begin{frame}{Relationship status: it's complicated}
  
The \textit{many-to-one} relationship is key to the expressiveness and efficiency of a relational system, but sometimes we have to work to make it represent what we want to represent

Example: Countries sign treaties, join organizations, and group together in various ways 
\begin{itemize}
  \item How to represent that?
\end{itemize}

Let us count the ways
\begin{itemize}
  \item Dummy variable strategy: new column called WTO that is true or false
\end{itemize}
Not great because there's lots of things to record about 
a country's relationship to the WTO and there are other organizations
\begin{itemize}
  \item e.g. joining date, leaving date
\end{itemize}
and all we've got is a yes / no (or a string)

\end{frame}
\begin{frame}{Relationship status: it's complicated}

How about the
\begin{itemize}
  \item Foreign key strategy: new foreign key relationship a table representing the WTO
\end{itemize}
But then we can't represent the joining and leaving dates for any particular country without even more columns

Also, why would we have a one row table called \textsf{WTO}?

\end{frame}

\begin{frame}{Relationship status: it's complicated}

Our problem is that countries have \textit{many-to-many} relationship with organizations:
\begin{itemize}
  \item Each country can be a member of more than one organization
  \item Each organization can have more than one country
\end{itemize}

Reconceptualize in terms of \textit{membership}
\begin{itemize}
  \item A membership connects a country to an organization
  \item It is the \textit{membership} that has beginning and ending dates of a \textit{membership} 
\end{itemize}
So represent membership as\ldots a table \textsf{Membership}, with columns:
\begin{itemize}
  \item \textsf{country\_id} (a foreign key to a row of \textsf{Country})
  \item \textsf{organization}: the name of the organization
  \item \textsf{begin\_date} and \textsf{end\_date} for that country
\end{itemize}
We can now represent as many organizations and organizational memberships as we like

\end{frame}
\begin{frame}{Membership has its privileges}

There's still something not quite right about this picture
\begin{itemize}
  \item Organizations are no more than things to belong to
  \item What if we wanted to record something about the 
  organization \textit{itself}, independent of its members?
  \item How do we stop the data entry folk from adding `World Trade Organization' and `WTO' and `W.T.O' as separate entries?
\end{itemize}

Organizations need to be more real. And you become real in a database model by being\ldots a table
  
\end{frame}
\begin{frame}{Membership has its privileges}

So we make another table \textsf{Organization} with columns 
\textsf{full\_name}, \textsf{abbreviation}, \textsf{start\_date}, \textsf{end\_date} 

Now each \textsf{Membership} has columns:
\begin{itemize}
  \item \textsf{country\_id} (a foreign key to a row of \textsf{Country})
  \item \textsf{organization\_id} (a foreign key to a row of \textsf{Organization})
  \item \textsf{begin\_date}: when the country joined
  \item \textsf{end\_date}: when the country left
\end{itemize}

\textit{Two} many-to-one relations and an intermediate `join' table completely represents the \textit{many-to-many} relationship between countries and organizations

\end{frame}

\begin{frame}{Foreign keys}
\medskip
\centerline{\includegraphics[scale = 0.4]{pics/final-schema}}  
\end{frame}

\begin{frame}{Joined up modelling}

Great, we've got our domain modelled, how to get data out of it?
\begin{itemize}
  \item it's query time
\end{itemize}

\medskip
The basic query type for database is (row) selection

In \textsf{SQL} it is the \textsf{SELECT} command
\begin{itemize}
  \item Equivalent to \textsf{dplyr}'s \textsf{filter},  \textsf{select}, \textsf{group\_by}, \textsf{summarise}, and \textsf{arrange}  functions
\end{itemize}
Built for single tables
	
For information spread out \textit{across} tables we'll need to join up the information so that select can operate on it

\end{frame}
\begin{frame}{Joined up modelling}

\centerline{\includegraphics[scale=0.3]{pics/sqlitesel}}
  
The `core' \textsf{SELECT} function syntax, from the \href{https://sqlite.org/lang_select.html}{sqlite3 homepage} (link).

\end{frame}




\begin{frame}[fragile]{Joins}

\begin{columns}[T,onlytextwidth]
\column{0.5\textwidth}

So if we joined \textsf{Investment} to \textsf{Country} on \textsf{country} we would get a table with the same number of rows as \textsf{Investment}, but extra columns corresponding to facts about the country mentioned in each row of \textsf{Investment}

\bigskip
There would be duplicated country information of source, but it would all be (redundantly) inline and available for filtering and selecting together.

\bigskip
\centerline{\includegraphics[scale=0.8]{pics/one-to-many}}

\column{0.04\textwidth}
\column{0.46\textwidth}
\pause

{\small
\begin{verbatim}
SELECT 
  inv.year, inv.sector, inv.value, 
  cou.name, cou.politics
FROM 
  Investment inv
LEFT JOIN 
  Country cou
ON 
  inv.country_id = cou.id;
\end{verbatim}
%\end{center}
}

\pause
\smallskip

{\small
\begin{verbatim}
left_join(Investment, Country, 
    by = c("country_id" = "id")) %>%
  select(year, sector, value, 
         name, politics)
\end{verbatim}
}

\end{columns}


\end{frame}

\begin{frame}{Joins}

In our example, if we want to select all countries that exceeded some threshold value in sector A while being a member of the WTO (phew) then we need to connect several
	
One (not the best) sequence of operations would be
\begin{itemize}
  \item Join \textsf{Investment} and \textsf{Country} and call it \textsf{InvCountry}
  \item Select the rows of \textsf{InvCountry} with values above threshold in  Sector A and only keep the unique ones
  \item Join \textsf{Organization} to \textsf{Membership} and call it \textsf{OrgMem} (gets the real names of the each organization)
  \item Join \textsf{OrgMem} to \textsf{InvCountry} where the organization name is `WTO', keeping only unique country names 
\end{itemize}

You can think of other ways to do this
\begin{itemize}
  \item Some are much more computationally efficient than others. This is `query optimization'
\end{itemize}

	
\end{frame}

\begin{frame}{Speed}

One of the key reasons people use relational representations is speed
\begin{itemize}
  \item Underneath, tables are not stored as tables but tree structures for fast retrieval
  \item These structures have been optimized for more than 20 years
\end{itemize}
If things are not going fast enough, then we can add
\textit{index}es to particular variables that we tend to select often
\begin{itemize}
  \item Advantage: speed
  \item Disadvantage: space
\end{itemize}
(Databases are generally a compromise between space and time)




	
\end{frame}


\begin{frame}{Views}

	Because the result of every join is another table it is sometimes useful to keep the results around
	
	This derived table (a table made by joining other table) is called a \textit{database view} (not all databases have them)
	
	Strengths:
	\begin{itemize}
  \item We get a non-normalized table, but it's only pretend. Our real data is efficiently stored
  \item Data entry doesn't see views so it is sane while the queries using the view are fast
\end{itemize}
	
	Limitations:
	\begin{itemize}
  \item You can't usually add or edit a view, just read from it
  \item It's extra computational work to keep the view current and human work to decide what business purposes deserve one
\end{itemize}
	
\end{frame}


\begin{frame}{Guarantees}

Traditional database systems offer \textit{guarantees}, usually summarised as ACID
\begin{itemize}
  \item Atomicity: If a country changes its name, the unit of work is [remove old name, add new name]. There's no time where the country has no name, and they 'roll back' together
  \item Consistency: There's never a point where the tables represent something impossible in the domain, e.g. if we remove the WTO row from \textsf{Organization} then all the \textsf{Membership} rows that contain its key will be deleted - the `cascade'
  \item Isolation: Even if the database does things in parallel it should never be possible to tell
  \item Durability: If something happened, then the system crashed, it should come back up still happened
\end{itemize}

Often hard to maintain at scale

NoSQL systems often deliberately violate these, e.g. offering `eventual consistency' or lacking durability
	
\end{frame}

\begin{frame}{Connect, only connect}
	
Databases need to communicate to the rest of the data science tools
\begin{itemize}
  \item by network connection (traditional)
  \item by pretending to be a programming language object 
\end{itemize}
(or often both)

\end{frame}
\begin{frame}{Network}

Databases are usually configured as servers.

Access by specifying 
\begin{itemize}
  \item URL with port
  \item login / username
  \item password
  \item etc.
\end{itemize}

\end{frame}

\begin{frame}{Postgres connection}

\centerline{\includegraphics[scale=0.4]{pics/connstr.png}}

\end{frame}

\begin{frame}{Network}

That gets you a \textit{database connection} that you send commands down, usually in \textsf{SQL}

If you run a query, you don't get results directly (there may be millions of rows), but rather a \textit{cursor}

A cursor is an imaginary row marker for all the rows that could be returned from your query
\begin{itemize}
  \item You ask the cursor for a row and you get the `next' one, or the next 50
\end{itemize}
	
\end{frame}
\begin{frame}{Faking it as an object}

This whole arrangement can be\ldots awkward

In \textit{applications} we often want to pretend that the result is a more familiar object, e.g.
\begin{itemize}
  \item In \textsf{R} we want result sets to look like \textsf{data.frame}s
  \item In \textsf{Python} we might want each row of the result to be an object, e.g. a \textsf{Country}
  \item In web applications may want to populate a web page template with result rows
\end{itemize}

This is broadly referred to as the \textit{impedance mismatch} (because that sounds more engineering that ontological mismatch)

Lots of tools do the translation for you
\begin{itemize}
  \item In \textsf{R}, \textsf{dbplyr}
  \item In \textsf{Python} the \textit{object-relational mapper}s, e.g. \textsf{SQLAlchemy}, \textsf{Dango ORM}
\end{itemize}

	
\end{frame}


\begin{frame}{Summing up}
  
Most data scientists never design an database
\begin{itemize}
  \item but they almost \textit{all} end up interacting with them
  \item and with DBAs
\end{itemize}
Lots of academic data work consists of working with \textit{bad reinventions} of the relational database
\begin{itemize}
  \item Looking at you, Excel-jockeys
\end{itemize}
\pause
Surprise: Thinking about data relationally will help you with \textit{statistics}
\begin{itemize}
  \item Multilevel models, time series analysis, network analysis
\end{itemize}
Tables are Concepts; columns are variables; rows are instances; foreign key relationships are nested variables, many-to-many relationships are crossed variables (possibly unbalanced)

  
\end{frame}

\begin{frame}{Databases}

Maybe not the most exciting technology, but awesomely useful and not going away

\end{frame}

\end{document}